# 8-事务隔离与MVCC多版本控制

### transaction id
innodb里面每一个事务都有一个唯一的事务ID transaction id。它是事务开始的时候，向innodb的事务系统申请的，是按照申请顺序严格递增的。

### MVCC
每行数据也是有多个版本的，每次事务更新数据的时候，都会生成一个新的版本，并且把transaction id赋值给这个数据版本的事务ID，记为row trx_id.同时旧的数据版本要保留，并且在新的数据版本中，可能通过某种方式获取到旧的数据版本。
数据库中的每一行记录，其实可能有多个版本，每个版本都有自己的row trx_id.

### 可见还是不可见？
一个事务A启动的时候，确定低水位、高水位
低水位：事务A启动时，已启动未提交的事务列表中最小的一个
高水位：事务A启动时，已启动的最大的transaction id+1

一个数据版本对于一个事务视图来说，有三种情况
1. 版本未提交，不可见
2. 版本已提交，但是在视图创建之后提交的，不可见
3. 版本已提交，而且是在视图创建前提交的，可见

对于可重复读，查询值承认在事务启动前就已经提交完成的数据
对于读提交，查询值承认在语句启动前就已经提交完成的数据。

### RR级别下启动事务创建快照
innodb利用了所有数据都有多个版本的特性，实现了秒级创建快照的能力。

### 当前度
事务中，更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）
事务中，select语句加锁，也可以实现当前读的效果，
select * from t where id=1 lock share mode;(S锁，共享锁)
select * from t where id=1 for update;（X锁，排它锁）

如果A事务已经获取r行数据的行锁(写锁)，B事务再去读取时，需要获取读锁，获取读锁时会等待A事务释放这个锁。

### 注意begin/start
begin/start transaction并不是一个事务的起点，在该语句之后的第一个操作innodb表的语句，事务才真正启动。如果想马上启动事务，可以使用start transaction with consistent snapshot。




