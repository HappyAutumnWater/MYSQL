#Mysql优化器的逻辑

设置慢查询日志阈值
set long_query_time=0;
强制使用a索引
select * from t force index(a) where a = 1;

-------


#### 优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。
影响执行代价的原因：
* 扫描行数（扫描行数越少，意味着访问磁盘数据的次数越少，消耗的CPU资源越少）
* 是否使用临时表
* 是否排序

#### MYSQL在真正开始执行语句之前，并不能精确的知道满足这个条件的记录有多少条，而只能根据每个索引的“区分度”来估算满足条件的记录数。
* show index中cardinality（“基数”），基数越大“区分度”越好。
* cardinality 是通过采样统计的方法计算出来的。
innodb会默认选择N个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，来计算cardinality。
当变更数据行数超过1/M的时候，会自动触发重新做一个索引统计。
* 使用 innodb_stats_persistent来设置N和M
设置为ON时，表示统计信息会持久化存储，默认N为20，M为10
设置为OFF时，表示统计信心只会存储在内存中，默认N为8，M为16
正式由于使用了采样统计，所以这个基数容易不准。

#### 重新统计索引信息
analyze table t;

#### 对于优化器误判的情况，
1、可以使用force index来强行制定索引，
2、或者通过修改sql语句来引导优化器，
3、还可以通过增加或者删除索引来绕过这个问题。





