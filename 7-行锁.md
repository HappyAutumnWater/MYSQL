# 7-行锁

select的时候innodb引擎不会加任何锁，可以使用一下语句强制加锁：
获取共享锁：select...from...where...lock in share mode
获取排它锁：select...from...where...for update

### 两阶段锁
再innodb事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束的时候才释放。这个就是两阶段锁协议。
根据《两阶段锁协议》，如果你的事务中需要锁多个行，则把最可能造成冲突的锁、最可能影响并发的锁往后放。

### 死锁：
当并系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态。

### 出现死锁有两种策略
1. 直接进入等待，直到超时。超时时间可以通过innodb_lock_wait_timeout来设置。
2. 发起死锁检测，发现死锁后，强制回滚死锁联调中的某一个事务，让其他的事务得以继续执行。设置参数：innodb_deadlock_detect 设置为on。		
通过innodb_lock_wait_timeout解决死锁的问题是时间设置太长，业务无法接受；时间设置太短，会出现误伤。所以一般情况使用死锁检测方式。

### 热点行更新问题
1000个并发线程更新同一个行，那么死锁检测就是100万量级的，最终的结果是没有死锁，但是消耗了大量的cpu资源。
	两种方式解决该问题：
	1. 如果能确保业务一定不会死锁，则可以临时关闭死锁检测。但是会出现大量超时。
	2. 控制并发度。比如同一行最多有10个线程更新。
	3. 从设计上优化这个问题，将一行数据改为逻辑上的多行来减少锁冲突。
	
	

