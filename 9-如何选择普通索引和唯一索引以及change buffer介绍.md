# 9-如何选择普通索引和唯一索引，以及change buffer介绍

###  问题1：
“更新一个数据页时，在不影响数据一致性的前提下，innodb会将这些更新操作缓存在change buffer中。”
具体有哪些操作呢？我想非唯一索引的更新操作，也需要判断该行数据是否存在，这样还是需要将磁盘中的数据页读取到内存中呢。

### 问题2：
有人说“真正对磁盘数据页的修改是通过将内存里脏页的数据刷回磁盘来完成的，而不是根据redolog”
更新时，如果数据页面在内存中，则会直接更新内存，然后在刷到磁盘中，这种场景对应上面的结论是没错的。
但如果需要更新的数据页不在内存中，先写change buffer，然后由后台线程定期merge，也是将磁盘上的数据页先读到内存中，在内存修改后，再同步到磁盘上的吗？

-------

## 一、唯一索引与普通索引区别：

### 1、查询过程
从索引树B+根节点开始，按层搜索到叶子节点，然后在数据页内部根据二分法来定位记录。
* 对于普通索引来说，查到第一个满足条件的记录之后，需要找下一个，直到碰到第一个不满足条件的记录。
* 对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。
但是以上差异造成的性能差距微乎其微，因为数据页已经加在到内存，内存中进行检索的性能消耗很小。innodb中每个数据页大小默认是16KB。
对于整型自字段，一个数据页可以放近千个Key。

### 2、更新过程
1. 当需要更新一个数据页时【注意是数据页】
*如果数据页在内存中就直接更新
*如果数据页不在内存中的话，在不影响数据一致性前提下，innodb会将这些更新操作缓存在change buffer中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页时，将数据页读入内存，然后执行change buffer中与这个页有关的操作，再将change buffer中的操作应用到原数据页，这个过程叫merge。
2. 发生merge时机：
	a、访问这个数据页
	b、后台线程定期merge
	c、数据库正常关闭（shutdown）时
3. change buffer 策略可以减少读磁盘、避免占用内存。
4. 对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反了唯一约束，而这个操作需要将数据页读入到内存才能判断，如果数据页已经读到内存中了，那么就没必要使用change buffer。
	所以唯一索引的更新就不能使用change buffer，实际上也只有普通索引可以使用。
	change buffer用的是buffer pool里的内存，因此不能无限增大，可以通过innodb_change_buffer_max_size来动态设置，对应的值代表最多占用buffer pool的百分之多少。
5. insert记录时
a、这个记录更新的目标页在内存中：
	*对于唯一索引，找到对应的位置，判断是否冲突，插入值。
	*对于普通索引，找到对一个的位置，插入值，少了判断是否冲突，但是性能差别很小。
b、这个记录更新的目标也不在内存中
	*对于唯一索引来说，将数据页读入内存，判断是否冲突，插入值。
	*对于普通索引来说，则将更新记录在change buffer中即可。
明显，当被更新的记录所在的数据页不在内存中时，普通索引不需要讲数据页读到内存中，所以不涉及《随机内存访问IO》，change buffer减少了随机磁盘访问，所以性能提升会很明显。

### 3、change buffer的使用场景
1. 普通索引
2. 写多，读少。账单类，日志类系统。
3. 写完之后立即查询的系统，不适合使用change buffer！
4. 如果使用机械硬盘时，change buffer效果十分显著，应当尽量开发change buffer的值，提升写入速度。




## 注意：
### 更新时顺序：
1. 判断数据页是否在内存中，若在内存中则直接更新；不在内存中则写入change buffer
2. 写入redo log
3. 异步将innodb buffer pool中的change buffer写到磁盘中 system table space(ibdata1)
 （change buffer内存部分在innodb buffer pool，硬盘部分在system table space（ibdata1））
4. 异步将内存中应用变更后的数据页，刷到磁盘中


### 读的时候，
先判断内存是否有最新值，如果有，则直接返回。如果没有则将数据页读取到内存中，将change buffer中的变更应用到数据页中，然后读取内存中的最新的数据页。实际读取之后，磁盘上的数据页还是旧的！！！

### 提升更新性能角度上change buffer和redo log的区别：
1. redo log主要节省的是随机写磁盘的IO消耗（转成顺序写）
2. change buffer主要节省的则是随机读磁盘的IO消耗


	
	


